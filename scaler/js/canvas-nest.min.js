/**
 * Copyright (c) 2016 hustcc
 * License: MIT
 * Version: v1.0.1
 * GitHub: https://github.com/hustcc/canvas-nest.js
**/
/**
 * CanvasNest.js  v1.0.1  中文注释版
 * 原仓库: https://github.com/hustcc/canvas-nest.js
 * 本版本仅作格式化和注释补充，未改变任何逻辑。
 *
 * 功能：在页面生成随鼠标互动的粒子连线背景。
 * 可配置参数（通过在 <script> 标签上写属性）：
 *   zIndex   : 画布层级   默认 -1
 *   opacity  : 透明度     默认 0.5
 *   color    : 线条颜色   默认 "0,0,0"  (RGB 字符串)
 *   count    : 粒子数量   默认 99
 */
(function () {
  /* ---------- 工具函数 ---------- */
  // 读取 <script> 标签上的自定义属性，没有则返回默认值
  function getAttr(el, attr, defaultVal) {
    return el.getAttribute(attr) || defaultVal;
  }

  // 按标签名获取 DOM 列表
  function $tag(tag) {
    return document.getElementsByTagName(tag);
  }

  /* ---------- 1. 读取用户配置 ---------- */
  function readConfig() {
    var scripts = $tag('script');
    var self = scripts[scripts.length - 1]; // 当前执行到的 script
    return {
      l: scripts.length,            // 给画布生成唯一 id 用
      z: getAttr(self, 'zIndex', -1),
      o: getAttr(self, 'opacity', 0.5),
      c: getAttr(self, 'color', '0,0,0'),
      n: getAttr(self, 'count', 200)
    };
  }

  /* ---------- 2. 画布尺寸 ---------- */
  var canvas = document.createElement('canvas');
  var ctx    = canvas.getContext('2d');
  var width, height;

  function resizeCanvas() {
    width  = canvas.width  = window.innerWidth
                            || document.documentElement.clientWidth
                            || document.body.clientWidth;
    height = canvas.height = window.innerHeight
                            || document.documentElement.clientHeight
                            || document.body.clientHeight;
  }

  /* ---------- 3. 生成配置、挂载画布 ---------- */
  var conf = readConfig();
  var canvasId = 'c_n' + conf.l;            // 唯一 id
  canvas.id   = canvasId;
  canvas.style.cssText = 'position:fixed;top:0;left:0;z-index:' + conf.z + ';opacity:' + conf.o;
  $tag('body')[0].appendChild(canvas);

  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  /* ---------- 4. 鼠标对象（用来连线） ---------- */
  var mouse = { x: null, y: null, max: 20000 }; // max 为影响半径平方

  window.addEventListener('mousemove', function (e) {
    e = e || window.event;
    mouse.x = e.clientX;
    mouse.y = e.clientY;
  });

  window.addEventListener('mouseout', function () {
    mouse.x = mouse.y = null;
  });

  /* ---------- 5. 粒子系统 ---------- */
  var particles = [];   // 所有粒子
  var random    = Math.random;

  // 初始化粒子
  for (var i = 0; i < conf.n; i++) {
    particles.push({
      x:  random() * width,
      y:  random() * height,
      xa: 2 * random() - 1,  // x 速度
      ya: 2 * random() - 1,  // y 速度
      max: 6000              // 连线最大距离平方
    });
  }

  // 把鼠标对象也放进数组，方便统一遍历
  var allNodes = particles.concat([mouse]);

  /* ---------- 6. 动画循环 ---------- */
  var raf = window.requestAnimationFrame
         || window.webkitRequestAnimationFrame
         || window.mozRequestAnimationFrame
         || window.oRequestAnimationFrame
         || window.msRequestAnimationFrame
         || function (cb) { setTimeout(cb, 1000 / 45); };

  function animate() {
    // 6.1 清空画布
    ctx.clearRect(0, 0, width, height);

    // 6.2 遍历每个粒子
    particles.forEach(function (pi, i) {
      // 6.2.1 更新位置
      pi.x += pi.xa;
      pi.y += pi.ya;

      // 碰壁反弹
      pi.xa *= (pi.x > width || pi.x < 0) ? -1 : 1;
      pi.ya *= (pi.y > height || pi.y < 0) ? -1 : 1;

      // 画一个 1px 的小点
      ctx.fillRect(pi.x - 0.5, pi.y - 0.5, 1, 1);

      // 6.2.2 与其它粒子（含鼠标）连线
      for (var j = i + 1; j < allNodes.length; j++) {
        var pj = allNodes[j];
        if (pj.x === null || pj.y === null) continue;

        var dx = pi.x - pj.x;
        var dy = pi.y - pj.y;
        var distSq = dx * dx + dy * dy;

        // 在影响范围内
        if (distSq < pj.max) {
          // 如果是鼠标且距离更近，粒子会被“吸”一下
          if (pj === mouse && distSq > pj.max / 2) {
            pi.x -= dx * 0.03;
            pi.y -= dy * 0.03;
          }

          // 连线透明度随距离变大而变小
          var ratio = (pj.max - distSq) / pj.max;
          ctx.beginPath();
          ctx.lineWidth = ratio / 2;
          ctx.strokeStyle = 'rgba(' + conf.c + ',' + (ratio + 0.2) + ')';
          ctx.moveTo(pi.x, pi.y);
          ctx.lineTo(pj.x, pj.y);
          ctx.stroke();
        }
      }
    });

    raf(animate);
  }

  // 延迟 100 ms 启动，避免页面未渲染完成
  setTimeout(function () {
    animate();
  }, 100);
})();
